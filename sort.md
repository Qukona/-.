# Алгоритмы сортировки и поиска

## Сортировка выбором (Selection Sort)

**Определение**: Алгоритм сортировки, который на каждом шаге находит минимальный элемент в неотсортированной части массива и помещает его в начало отсортированной части.

**Временная сложность**: O(n²)
- Внешний цикл выполняется n раз
- Внутренний цикл в среднем выполняется n/2 раз
- Общее количество операций: n × (n/2) = n²/2 → O(n²)

### Python
Объяснение работы алгоритма:
- Внешний цикл for i in range(len(arr)) проходит по всем элементам массива от начала до конца
- Внутренний цикл for j in range(i + 1, len(arr)) ищет минимальный элемент в неотсортированной части массива
- Условный оператор if arr[j] < arr[min_index] сравнивает текущий элемент с текущим минимумом
- Операция обмена arr[i], arr[min_index] = arr[min_index], arr[i] перемещает найденный минимальный элемент на текущую позицию

Ввод: [64, 25, 12, 22, 11]
Вывод: [11, 12, 22, 25, 64]

### Java
Объяснение работы алгоритма:
- Внешний цикл for (int i = 0; i < arr.length; i++) проходит по всем элементам массива от начала до конца
- Внутренний цикл for (int j = i + 1; j < arr.length; j++) ищет минимальный элемент в неотсортированной части массива
- Условный оператор if (arr[j] < arr[minIndex]) сравнивает текущий элемент с текущим минимумом
- Операция обмена через временную переменную temp перемещает найденный минимальный элемент на текущую позицию

Ввод: [64, 25, 12, 22, 11]
Вывод: [11, 12, 22, 25, 64]

### C++
Объяснение работы алгоритма:
- Внешний цикл for (int i = 0; i < arr.size(); i++) проходит по всем элементам вектора от начала до конца
- Внутренний цикл for (int j = i + 1; j < arr.size(); j++) ищет минимальный элемент в неотсортированной части вектора
- Условный оператор if (arr[j] < arr[minIndex]) сравнивает текущий элемент с текущим минимумом
- Функция swap(arr[i], arr[minIndex]) меняет местами текущий элемент с минимальным найденным элементом

Ввод: [64, 25, 12, 22, 11]
Вывод: [11, 12, 22, 25, 64]

## Сортировка пузырьком (Bubble Sort)

**Определение**: Алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

**Временная сложность**: O(n²)
- В худшем случае (массив отсортирован в обратном порядке) требуется n-1 проходов
- Каждый проход обрабатывает n-1, n-2, ..., 1 элементов
- Общее количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2 → O(n²)

### Python
Объяснение работы алгоритма:
- Внешний цикл for i in range(n) контролирует количество проходов по массиву
- Внутренний цикл for j in range(0, n - i - 1) проходит по неотсортированной части массива
- Условный оператор if arr[j] > arr[j + 1] проверяет правильность порядка соседних элементов
- Операция обмена arr[j], arr[j + 1] = arr[j + 1], arr[j] меняет элементы местами при нарушении порядка

Ввод: [64, 34, 25, 12, 22, 11, 90]
Вывод: [11, 12, 22, 25, 34, 64, 90]

### Java
Объяснение работы алгоритма:
- Внешний цикл for (int i = 0; i < n-1; i++) контролирует количество проходов по массиву
- Внутренний цикл for (int j = 0; j < n-i-1; j++) проходит по неотсортированной части массива
- Условный оператор if (arr[j] > arr[j+1]) проверяет правильность порядка соседних элементов
- Операция обмена через временную переменную temp меняет элементы местами при нарушении порядка

Ввод: [64, 34, 25, 12, 22, 11, 90]
Вывод: [11, 12, 22, 25, 34, 64, 90]

### C++
Объяснение работы алгоритма:
- Внешний цикл for (int i = 0; i < n-1; i++) контролирует количество проходов по вектору
- Внутренний цикл for (int j = 0; j < n-i-1; j++) проходит по неотсортированной части вектора
- Условный оператор if (arr[j] > arr[j+1]) проверяет правильность порядка соседних элементов
- Функция swap(arr[j], arr[j+1]) меняет элементы местами при нарушении порядка

Ввод: [64, 34, 25, 12, 22, 11, 90]
Вывод: [11, 12, 22, 25, 34, 64, 90]

## Сортировка вставками (Insertion Sort)

**Определение**: Алгоритм, который строит отсортированную последовательность, постепенно вставляя элементы на правильные позиции в уже отсортированной части массива.

**Временная сложность**: O(n²)
- В худшем случае (обратно отсортированный массив) каждый новый элемент требует сдвига всех предыдущих
- Для каждого из n элементов выполняется до n сравнений и сдвигов
- Общее количество операций: 1 + 2 + 3 + ... + (n-1) = n(n-1)/2 → O(n²)

### Python
Объяснение работы алгоритма:
- Цикл for i in range(1, len(arr)) начинается со второго элемента массива
- Переменная key = arr[i] сохраняет текущий элемент для вставки
- Цикл while j >= 0 and arr[j] > key сдвигает элементы больше key вправо
- Операция arr[j + 1] = key вставляет элемент на правильную позицию в отсортированной части

Ввод: [12, 11, 13, 5, 6]
Вывод: [5, 6, 11, 12, 13]

### Java
Объяснение работы алгоритма:
- Цикл for (int i = 1; i < arr.length; i++) начинается со второго элемента массива
- Переменная key = arr[i] сохраняет текущий элемент для вставки
- Цикл while (j >= 0 && arr[j] > key) сдвигает элементы больше key вправо
- Операция arr[j + 1] = key вставляет элемент на правильную позицию в отсортированной части

Ввод: [12, 11, 13, 5, 6]
Вывод: [5, 6, 11, 12, 13]

### C++
Объяснение работы алгоритма:
- Цикл for (int i = 1; i < arr.size(); i++) начинается со второго элемента вектора
- Переменная key = arr[i] сохраняет текущий элемент для вставки
- Цикл while (j >= 0 && arr[j] > key) сдвигает элементы больше key вправо
- Операция arr[j + 1] = key вставляет элемент на правильную позицию в отсортированной части

Ввод: [12, 11, 13, 5, 6]
Вывод: [5, 6, 11, 12, 13]

## Сортировка слиянием (Merge Sort)

**Определение**: Эффективный алгоритм "разделяй и властвуй", который рекурсивно разделяет массив на две части, сортирует их и затем объединяет в отсортированную последовательность.

**Временная сложность**: O(n log n)
- Массив делится пополам на каждом уровне рекурсии: log n уровней
- На каждом уровне выполняется слияние всех элементов: n операций
- Общая сложность: n × log n → O(n log n)

### Python
Объяснение работы алгоритма:
- Рекурсивное разделение массива на две части до базового случая (массив из 1 элемента)
- Функция merge_sort рекурсивно вызывает себя для левой и правой половин
- Функция merge объединяет два отсортированных массива в один отсортированный
- Использование указателей i и j для последовательного слияния элементов

Ввод: [38, 27, 43, 3, 9, 82, 10]
Вывод: [3, 9, 10, 27, 38, 43, 82]

### Java
Объяснение работы алгоритма:
- Рекурсивное разделение массива на две части методом mergeSort
- Создание временных массивов L и R для хранения левой и правой половин
- Функция merge объединяет два отсортированных подмассива в один
- Использование трех указателей для слияния элементов в правильном порядке

Ввод: [38, 27, 43, 3, 9, 82, 10]
Вывод: [3, 9, 10, 27, 38, 43, 82]

### C++
Объяснение работы алгоритма:
- Рекурсивное разделение вектора на две части с вычислением середины
- Создание временных векторов L и R для левой и правой половин
- Функция merge объединяет отсортированные подвекторы обратно в исходный вектор
- Использование индексов для последовательного слияния элементов

Ввод: [38, 27, 43, 3, 9, 82, 10]
Вывод: [3, 9, 10, 27, 38, 43, 82]

## Сортировка Шелла (Shell Sort)

**Определение**: Улучшенная версия сортировки вставками, которая сортирует элементы на определенных расстояниях (промежутках), постепенно уменьшая промежуток до 1.

**Временная сложность**: O(n²) в худшем случае
- Зависит от выбора последовательности промежутков
- В худшем случае (плохая последовательность) сложность квадратичная
- В лучшем случае может достигать O(n log² n)

### Python
Объяснение работы алгоритма:
- Цикл while gap > 0 последовательно уменьшает шаг сортировки от n/2 до 1
- Внутренний цикл for i in range(gap, n) проходит по элементам с текущим шагом
- Вложенный цикл while j >= gap and arr[j - gap] > temp сдвигает элементы на расстоянии gap
- Операция arr[j] = temp вставляет элемент на правильную позицию внутри подгруппы

Ввод: [12, 34, 54, 2, 3]
Вывод: [2, 3, 12, 34, 54]

### Java
Объяснение работы алгоритма:
- Использование последовательности промежутков, начиная с n/2
- Вложенные циклы для сортировки элементов на определенном расстоянии
- Постепенное уменьшение промежутка до полной сортировки
- Эффективное перемещение элементов на большие расстояния

Ввод: [12, 34, 54, 2, 3]
Вывод: [2, 3, 12, 34, 54]

### C++
Объяснение работы алгоритма:
- Цикл for (int gap = n/2; gap > 0; gap /= 2) уменьшает шаг сортировки
- Внутренний цикл проходит по элементам с текущим промежутком
- Сдвиг элементов внутри подгрупп для частичной сортировки
- Постепенное уменьшение промежутка для окончательной сортировки

Ввод: [12, 34, 54, 2, 3]
Вывод: [2, 3, 12, 34, 54]

## Быстрая сортировка (Quick Sort)

**Определение**: Алгоритм "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на элементы меньше опорного, равные ему и больше.

**Временная сложность**: O(n log n) в среднем случае
- В среднем случае массив делится пополам на каждом уровне: log n уровней
- На каждом уровне выполняется n операций разделения
- В худшем случае (уже отсортированный массив) сложность O(n²)

### Python
Объяснение работы алгоритма:
- Выбор опорного элемента pivot = arr[len(arr) // 2] из середины массива
- Разделение на три списка с помощью list comprehensions: элементы меньше, равные и больше опорного
- Рекурсивные вызовы quick_sort(left) и quick_sort(right) для сортировки подмассивов
- Конкатенация отсортированных частей оператором + в окончательный результат

Ввод: [10, 7, 8, 9, 1, 5]
Вывод: [1, 5, 7, 8, 9, 10]

### Java
Объяснение работы алгоритма:
- Выбор опорного элемента как последнего элемента массива
- Функция partition перераспределяет элементы относительно опорного
- Рекурсивные вызовы quickSort для левой и правой частей
- Разделение массива на элементы меньше и больше опорного

Ввод: [10, 7, 8, 9, 1, 5]
Вывод: [1, 5, 7, 8, 9, 10]

### C++
Объяснение работы алгоритма:
- Функция partition выбирает опорный элемент и перестраивает вектор
- Разделение на элементы меньше опорного и больше опорного
- Рекурсивная сортировка левой и правой частей
- Использование индексов для эффективного разделения

Ввод: [10, 7, 8, 9, 1, 5]
Вывод: [1, 5, 7, 8, 9, 10]

## Пирамидальная сортировка (Heap Sort)

**Определение**: Алгоритм, использующий структуру данных "куча" (heap) для сортировки элементов.

**Временная сложность**: O(n log n)
- Построение кучи: O(n)
- Каждое из n извлечений максимума: O(log n)
- Общая сложность: O(n) + n × O(log n) = O(n log n)

### Python
Объяснение работы алгоритма:
- Функция heapify поддерживает свойство max-heap для поддерева
- Построение max-heap из всего массива
- Последовательное извлечение максимального элемента и помещение его в конец
- Перестроение кучи после каждого извлечения

Ввод: [12, 11, 13, 5, 6, 7]
Вывод: [5, 6, 7, 11, 12, 13]

### Java
Объяснение работы алгоритма:
- Построение max-heap вызовами heapify снизу вверх
- Извлечение корня кучи (максимального элемента) и помещение в конец массива
- Восстановление свойства кучи после каждого извлечения
- Рекурсивная функция heapify для поддержки структуры кучи

Ввод: [12, 11, 13, 5, 6, 7]
Вывод: [5, 6, 7, 11, 12, 13]

### C++
Объяснение работы алгоритма:
- Построение max-heap из исходного вектора
- Последовательное извлечение максимального элемента из кучи
- Перемещение корня кучи в конец вектора
- Восстановление свойства кучи после каждого перемещения

Ввод: [12, 11, 13, 5, 6, 7]
Вывод: [5, 6, 7, 11, 12, 13]

## Линейный поиск (Linear Search)

**Определение**: Простейший алгоритм поиска, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент.

**Временная сложность**: O(n)
- В худшем случае требуется проверить все n элементов
- В среднем случае проверяется n/2 элементов
- Сложность линейно зависит от размера массива

### Python
Объяснение работы алгоритма:
- Цикл for i in range(len(arr)) последовательно проверяет каждый элемент массива
- Условный оператор if arr[i] == target сравнивает текущий элемент с искомым значением
- Оператор return i немедленно возвращает индекс при нахождении элемента
- Оператор return -1 возвращает -1 если элемент не найден после полного прохода по массиву

Ввод: массив [3, 5, 2, 7, 9, 1, 4], искомый элемент 7
Вывод: Элемент найден на позиции: 3

### Java
Объяснение работы алгоритма:
- Цикл for (int i = 0; i < arr.length; i++) проходит по всем элементам массива
- Сравнение каждого элемента с целевым значением
- Немедленный возврат индекса при нахождении элемента
- Возврат -1 после полного прохода если элемент не найден

Ввод: массив [3, 5, 2, 7, 9, 1, 4], искомый элемент 7
Вывод: Элемент найден на позиции: 3

### C++
Объяснение работы алгоритма:
- Цикл for (int i = 0; i < arr.size(); i++) проходит по всем элементам вектора
- Сравнение текущего элемента с искомым значением
- Возврат индекса при совпадении значений
- Возврат -1 если элемент отсутствует в векторе

Ввод: массив [3, 5, 2, 7, 9, 1, 4], искомый элемент 7
Вывод: Элемент найден на позиции: 3

## Бинарный поиск (Binary Search)

**Определение**: Эффективный алгоритм поиска в отсортированном массиве, который на каждом шаге делит область поиска пополам.

**Временная сложность**: O(log n)
- На каждом шаге область поиска уменьшается вдвое
- Максимальное количество шагов: log₂n
- Сложность логарифмическая относительно размера массива

### Python
Объяснение работы алгоритма:
- Инициализация границ поиска left и right
- Цикл while left <= right продолжается пока есть элементы для проверки
- Вычисление среднего элемента mid = (left + right) // 2
- Сравнение среднего элемента с целевым значением и корректировка границ

Ввод: отсортированный массив [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], искомый элемент 7
Вывод: Элемент найден на позиции: 3

### Java
Объяснение работы алгоритма:
- Установка начальных границ поиска от 0 до длины массива минус 1
- Вычисление середины с предотвращением переполнения
- Сужение области поиска в зависимости от сравнения
- Возврат индекса при нахождении или -1 при отсутствии

Ввод: отсортированный массив [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], искомый элемент 7
Вывод: Элемент найден на позиции: 3

### C++
Объяснение работы алгоритма:
- Переменные left и right определяют текущие границы поиска в отсортированном массиве
- Цикл while (left <= right) продолжается пока есть непроверенные элементы
- Вычисление середины mid = left + (right - left) / 2 предотвращает переполнение
- Условные операторы корректируют границы поиска в зависимости от сравнения с целевым значением
- Возврат индекса при нахождении или -1 при отсутствии элемента

Ввод: отсортированный массив [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], искомый элемент 7
Вывод: Элемент найден на позиции: 3
[file content end]
