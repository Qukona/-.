Сортировка выбором (Python)

Объяснение работы алгоритма:

    Внешний цикл for i in range(len(arr)) проходит по всем элементам массива от начала до конца

    Внутренний цикл for j in range(i + 1, len(arr)) ищет минимальный элемент в неотсортированной части массива

    Условный оператор if arr[j] < arr[min_index] сравнивает текущий элемент с текущим минимумом

    Операция обмена arr[i], arr[min_index] = arr[min_index], arr[i] перемещает найденный минимальный элемент на текущую позицию

Ввод: [64, 25, 12, 22, 11]
Вывод: [11, 12, 22, 25, 64]
Временная сложность: O(n²)
Сортировка выбором (Java)

Объяснение работы алгоритма:

    Внешний цикл for (int i = 0; i < arr.length; i++) проходит по всем элементам массива от начала до конца

    Внутренний цикл for (int j = i + 1; j < arr.length; j++) ищет минимальный элемент в неотсортированной части массива

    Условный оператор if (arr[j] < arr[minIndex]) сравнивает текущий элемент с текущим минимумом

    Операция обмена через временную переменную temp перемещает найденный минимальный элемент на текущую позицию

Ввод: [64, 25, 12, 22, 11]
Вывод: [11, 12, 22, 25, 64]
Временная сложность: O(n²)
Сортировка выбором (C++)

Объяснение работы алгоритма:

    Внешний цикл for (int i = 0; i < arr.size(); i++) проходит по всем элементам вектора от начала до конца

    Внутренний цикл for (int j = i + 1; j < arr.size(); j++) ищет минимальный элемент в неотсортированной части вектора

    Условный оператор if (arr[j] < arr[minIndex]) сравнивает текущий элемент с текущим минимумом

    Функция swap(arr[i], arr[minIndex]) меняет местами текущий элемент с минимальным найденным элементом

Ввод: [64, 25, 12, 22, 11]
Вывод: [11, 12, 22, 25, 64]
Временная сложность: O(n²)
Сортировка пузырьком (Python)

Объяснение работы алгоритма:

    Внешний цикл for i in range(n) контролирует количество проходов по массиву

    Внутренний цикл for j in range(0, n - i - 1) проходит по неотсортированной части массива

    Условный оператор if arr[j] > arr[j + 1] проверяет правильность порядка соседних элементов

    Операция обмена arr[j], arr[j + 1] = arr[j + 1], arr[j] меняет элементы местами при нарушении порядка

Ввод: [64, 34, 25, 12, 22, 11, 90]
Вывод: [11, 12, 22, 25, 34, 64, 90]
Временная сложность: O(n²)
Сортировка пузырьком (Java)

Объяснение работы алгоритма:

    Внешний цикл for (int i = 0; i < n-1; i++) контролирует количество проходов по массиву

    Внутренний цикл for (int j = 0; j < n-i-1; j++) проходит по неотсортированной части массива

    Условный оператор if (arr[j] > arr[j+1]) проверяет правильность порядка соседних элементов

    Операция обмена через временную переменную temp меняет элементы местами при нарушении порядка

Ввод: [64, 34, 25, 12, 22, 11, 90]
Вывод: [11, 12, 22, 25, 34, 64, 90]
Временная сложность: O(n²)
Сортировка пузырьком (C++)

Объяснение работы алгоритма:

    Внешний цикл for (int i = 0; i < n-1; i++) контролирует количество проходов по вектору

    Внутренний цикл for (int j = 0; j < n-i-1; j++) проходит по неотсортированной части вектора

    Условный оператор if (arr[j] > arr[j+1]) проверяет правильность порядка соседних элементов

    Функция swap(arr[j], arr[j+1]) меняет элементы местами при нарушении порядка

Ввод: [64, 34, 25, 12, 22, 11, 90]
Вывод: [11, 12, 22, 25, 34, 64, 90]
Временная сложность: O(n²)
Сортировка вставками (Python)

Объяснение работы алгоритма:

    Цикл for i in range(1, len(arr)) начинается со второго элемента массива

    Переменная key = arr[i] сохраняет текущий элемент для вставки

    Цикл while j >= 0 and arr[j] > key сдвигает элементы больше key вправо

    Операция arr[j + 1] = key вставляет элемент на правильную позицию в отсортированной части

Ввод: [12, 11, 13, 5, 6]
Вывод: [5, 6, 11, 12, 13]
Временная сложность: O(n²)
Сортировка вставками (Java)

Объяснение работы алгоритма:

    Цикл for (int i = 1; i < arr.length; i++) начинается со второго элемента массива

    Переменная key = arr[i] сохраняет текущий элемент для вставки

    Цикл while (j >= 0 && arr[j] > key) сдвигает элементы больше key вправо

    Операция arr[j + 1] = key вставляет элемент на правильную позицию в отсортированной части

Ввод: [12, 11, 13, 5, 6]
Вывод: [5, 6, 11, 12, 13]
Временная сложность: O(n²)
Сортировка вставками (C++)

Объяснение работы алгоритма:

    Цикл for (int i = 1; i < arr.size(); i++) начинается со второго элемента вектора

    Переменная key = arr[i] сохраняет текущий элемент для вставки

    Цикл while (j >= 0 && arr[j] > key) сдвигает элементы больше key вправо

    Операция arr[j + 1] = key вставляет элемент на правильную позицию в отсортированной части

Ввод: [12, 11, 13, 5, 6]
Вывод: [5, 6, 11, 12, 13]
Временная сложность: O(n²)
Сортировка слиянием (Python)

Объяснение работы алгоритма:

    Рекурсивное разделение массива на две части до базового случая (массив из 1 элемента)

    Функция merge_sort рекурсивно вызывает себя для левой и правой половин

    Функция merge объединяет два отсортированных массива в один отсортированный

    Использование указателей i и j для последовательного слияния элементов

Ввод: [38, 27, 43, 3, 9, 82, 10]
Вывод: [3, 9, 10, 27, 38, 43, 82]
Временная сложность: O(n log n)
Сортировка слиянием (Java)

Объяснение работы алгоритма:

    Рекурсивное разделение массива на две части методом mergeSort

    Создание временных массивов L и R для хранения левой и правой половин

    Функция merge объединяет два отсортированных подмассива в один

    Использование трех указателей для слияния элементов в правильном порядке

Ввод: [38, 27, 43, 3, 9, 82, 10]
Вывод: [3, 9, 10, 27, 38, 43, 82]
Временная сложность: O(n log n)
Сортировка слиянием (C++)

Объяснение работы алгоритма:

    Рекурсивное разделение вектора на две части с вычислением середины

    Создание временных векторов L и R для левой и правой половин

    Функция merge объединяет отсортированные подвекторы обратно в исходный вектор

    Использование индексов для последовательного слияния элементов

Ввод: [38, 27, 43, 3, 9, 82, 10]
Вывод: [3, 9, 10, 27, 38, 43, 82]
Временная сложность: O(n log n)
Сортировка Шелла (Python)

Объяснение работы алгоритма:

    Цикл while gap > 0 последовательно уменьшает шаг сортировки от n/2 до 1

    Внутренний цикл for i in range(gap, n) проходит по элементам с текущим шагом

    Вложенный цикл while j >= gap and arr[j - gap] > temp сдвигает элементы на расстоянии gap

    Операция arr[j] = temp вставляет элемент на правильную позицию внутри подгруппы

Ввод: [12, 34, 54, 2, 3]
Вывод: [2, 3, 12, 34, 54]
Временная сложность: O(n²) в худшем случае
Сортировка Шелла (Java)

Объяснение работы алгоритма:

    Использование последовательности промежутков, начиная с n/2

    Вложенные циклы для сортировки элементов на определенном расстоянии

    Постепенное уменьшение промежутка до полной сортировки

    Эффективное перемещение элементов на большие расстояния

Ввод: [12, 34, 54, 2, 3]
Вывод: [2, 3, 12, 34, 54]
Временная сложность: O(n²) в худшем случае
Сортировка Шелла (C++)

Объяснение работы алгоритма:

    Цикл for (int gap = n/2; gap > 0; gap /= 2) уменьшает шаг сортировки

    Внутренний цикл проходит по элементам с текущим промежутком

    Сдвиг элементов внутри подгрупп для частичной сортировки

    Постепенное уменьшение промежутка для окончательной сортировки

Ввод: [12, 34, 54, 2, 3]
Вывод: [2, 3, 12, 34, 54]
Временная сложность: O(n²) в худшем случае
Быстрая сортировка (Python)

Объяснение работы алгоритма:

    Выбор опорного элемента pivot = arr[len(arr) // 2] из середины массива

    Разделение на три списка с помощью list comprehensions: элементы меньше, равные и больше опорного

    Рекурсивные вызовы quick_sort(left) и quick_sort(right) для сортировки подмассивов

    Конкатенация отсортированных частей оператором + в окончательный результат

Ввод: [10, 7, 8, 9, 1, 5]
Вывод: [1, 5, 7, 8, 9, 10]
Временная сложность: O(n log n) в среднем случае
Быстрая сортировка (Java)

Объяснение работы алгоритма:

    Выбор опорного элемента как последнего элемента массива

    Функция partition перераспределяет элементы относительно опорного

    Рекурсивные вызовы quickSort для левой и правой частей

    Разделение массива на элементы меньше и больше опорного

Ввод: [10, 7, 8, 9, 1, 5]
Вывод: [1, 5, 7, 8, 9, 10]
Временная сложность: O(n log n) в среднем случае
Быстрая сортировка (C++)

Объяснение работы алгоритма:

    Функция partition выбирает опорный элемент и перестраивает вектор

    Разделение на элементы меньше опорного и больше опорного

    Рекурсивная сортировка левой и правой частей

    Использование индексов для эффективного разделения

Ввод: [10, 7, 8, 9, 1, 5]
Вывод: [1, 5, 7, 8, 9, 10]
Временная сложность: O(n log n) в среднем случае
Пирамидальная сортировка (Python)

Объяснение работы алгоритма:

    Функция heapify поддерживает свойство max-heap для поддерева

    Построение max-heap из всего массива

    Последовательное извлечение максимального элемента и помещение его в конец

    Перестроение кучи после каждого извлечения

Ввод: [12, 11, 13, 5, 6, 7]
Вывод: [5, 6, 7, 11, 12, 13]
Временная сложность: O(n log n)
Пирамидальная сортировка (Java)

Объяснение работы алгоритма:

    Построение max-heap вызовами heapify снизу вверх

    Извлечение корня кучи (максимального элемента) и помещение в конец массива

    Восстановление свойства кучи после каждого извлечения

    Рекурсивная функция heapify для поддержки структуры кучи

Ввод: [12, 11, 13, 5, 6, 7]
Вывод: [5, 6, 7, 11, 12, 13]
Временная сложность: O(n log n)
Пирамидальная сортировка (C++)

Объяснение работы алгоритма:

    Построение max-heap из исходного вектора

    Последовательное извлечение максимального элемента из кучи

    Перемещение корня кучи в конец вектора

    Восстановление свойства кучи после каждого перемещения

Ввод: [12, 11, 13, 5, 6, 7]
Вывод: [5, 6, 7, 11, 12, 13]
Временная сложность: O(n log n)
Линейный поиск (Python)

Объяснение работы алгоритма:

    Цикл for i in range(len(arr)) последовательно проверяет каждый элемент массива

    Условный оператор if arr[i] == target сравнивает текущий элемент с искомым значением

    Оператор return i немедленно возвращает индекс при нахождении элемента

    Оператор return -1 возвращает -1 если элемент не найден после полного прохода по массиву

Ввод: массив [3, 5, 2, 7, 9, 1, 4], искомый элемент 7
Вывод: Элемент найден на позиции: 3
Временная сложность: O(n)
Линейный поиск (Java)

Объяснение работы алгоритма:

    Цикл for (int i = 0; i < arr.length; i++) проходит по всем элементам массива

    Сравнение каждого элемента с целевым значением

    Немедленный возврат индекса при нахождении элемента

    Возврат -1 после полного прохода если элемент не найден

Ввод: массив [3, 5, 2, 7, 9, 1, 4], искомый элемент 7
Вывод: Элемент найден на позиции: 3
Временная сложность: O(n)
Линейный поиск (C++)

Объяснение работы алгоритма:

    Цикл for (int i = 0; i < arr.size(); i++) проходит по всем элементам вектора

    Сравнение текущего элемента с искомым значением

    Возврат индекса при совпадении значений

    Возврат -1 если элемент отсутствует в векторе

Ввод: массив [3, 5, 2, 7, 9, 1, 4], искомый элемент 7
Вывод: Элемент найден на позиции: 3
Временная сложность: O(n)
Бинарный поиск (Python)

Объяснение работы алгоритма:

    Инициализация границ поиска left и right

    Цикл while left <= right продолжается пока есть элементы для проверки

    Вычисление среднего элемента mid = (left + right) // 2

    Сравнение среднего элемента с целевым значением и корректировка границ

Ввод: отсортированный массив [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], искомый элемент 7
Вывод: Элемент найден на позиции: 3
Временная сложность: O(log n)
Бинарный поиск (Java)

Объяснение работы алгоритма:

    Установка начальных границ поиска от 0 до длины массива минус 1

    Вычисление середины с предотвращением переполнения

    Сужение области поиска в зависимости от сравнения

    Возврат индекса при нахождении или -1 при отсутствии

Ввод: отсортированный массив [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], искомый элемент 7
Вывод: Элемент найден на позиции: 3
Временная сложность: O(log n)
Бинарный поиск (C++)

Объяснение работы алгоритма:

    Переменные left и right определяют текущие границы поиска в отсортированном массиве

    Цикл while (left <= right) продолжается пока есть непроверенные элементы

    Вычисление середины mid = left + (right - left) / 2 предотвращает переполнение

    Условные операторы корректируют границы поиска в зависимости от сравнения с целевым значением

    Возврат индекса при нахождении или -1 при отсутствии элемента

Ввод: отсортированный массив [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], искомый элемент 7
Вывод: Элемент найден на позиции: 3
Временная сложность: O(log n
