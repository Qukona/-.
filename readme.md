Объяснения работы алгоритмов
Сортировка выбором (Python)

Объяснение работы алгоритма:

    Внешний цикл for i in range(len(arr)) проходит по всем элементам массива от начала до конца

    Внутренний цикл for j in range(i + 1, len(arr)) ищет минимальный элемент в неотсортированной части массива

    Условный оператор if arr[j] < arr[min_index] сравнивает текущий элемент с текущим минимумом

    Операция обмена arr[i], arr[min_index] = arr[min_index], arr[i] перемещает найденный минимальный элемент на текущую позицию

Ввод: [64, 25, 12, 22, 11]
Вывод: [11, 12, 22, 25, 64]
Временная сложность: O(n²)
Сортировка пузырьком (Python)

Объяснение работы алгоритма:

    Внешний цикл for i in range(n) контролирует количество проходов по массиву

    Внутренний цикл for j in range(0, n - i - 1) проходит по неотсортированной части массива

    Условный оператор if arr[j] > arr[j + 1] проверяет правильность порядка соседних элементов

    Операция обмена arr[j], arr[j + 1] = arr[j + 1], arr[j] меняет элементы местами при нарушении порядка

Ввод: [64, 34, 25, 12, 22, 11, 90]
Вывод: [11, 12, 22, 25, 34, 64, 90]
Временная сложность: O(n²)
Сортировка вставками (C++)

Объяснение работы алгоритма:

    Цикл for (int i = 1; i < arr.size(); i++) начинается со второго элемента массива

    Переменная key = arr[i] сохраняет текущий элемент для вставки

    Цикл while (j >= 0 && arr[j] > key) сдвигает элементы больше key вправо

    Операция arr[j + 1] = key вставляет элемент на правильную позицию в отсортированной части

Ввод: [12, 11, 13, 5, 6]
Вывод: [5, 6, 11, 12, 13]
Временная сложность: O(n²)
Сортировка Шелла (Python)

Объяснение работы алгоритма:

    Цикл while gap > 0 последовательно уменьшает шаг сортировки от n/2 до 1

    Внутренний цикл for i in range(gap, n) проходит по элементам с текущим шагом

    Вложенный цикл while j >= gap and arr[j - gap] > temp сдвигает элементы на расстоянии gap

    Операция arr[j] = temp вставляет элемент на правильную позицию внутри подгруппы

Ввод: [12, 34, 54, 2, 3]
Вывод: [2, 3, 12, 34, 54]
Временная сложность: O(n²) в худшем случае
Быстрая сортировка (Python)

Объяснение работы алгоритма:

    Выбор опорного элемента pivot = arr[len(arr) // 2] из середины массива

    Разделение на три списка с помощью list comprehensions: элементы меньше, равные и больше опорного

    Рекурсивные вызовы quick_sort(left) и quick_sort(right) для сортировки подмассивов

    Конкатенация отсортированных частей оператором + в окончательный результат

Ввод: [10, 7, 8, 9, 1, 5]
Вывод: [1, 5, 7, 8, 9, 10]
Временная сложность: O(n log n) в среднем случае
Линейный поиск (Python)

Объяснение работы алгоритма:

    Цикл for i in range(len(arr)) последовательно проверяет каждый элемент массива

    Условный оператор if arr[i] == target сравнивает текущий элемент с искомым значением

    Оператор return i немедленно возвращает индекс при нахождении элемента

    Оператор return -1 возвращает -1 если элемент не найден после полного прохода по массиву

Ввод: массив [3, 5, 2, 7, 9, 1, 4], искомый элемент 7
Вывод: Элемент найден на позиции: 3
Временная сложность: O(n)
Бинарный поиск (C++)

Объяснение работы алгоритма:

    Переменные left и right определяют текущие границы поиска в отсортированном массиве

    Цикл while (left <= right) продолжается пока есть непроверенные элементы

    Вычисление середины mid = left + (right - left) / 2 предотвращает переполнение

    Условные операторы корректируют границы поиска в зависимости от сравнения с целевым значением

    Возврат индекса при нахождении или -1 при отсутствии элемента

Ввод: отсортированный массив [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], искомый элемент 7
Вывод: Элемент найден на позиции: 3
Временная сложность: O(log n)
